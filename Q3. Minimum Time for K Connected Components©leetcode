class Solution {
public:
    struct DSU {
        vector<int> p, sz;
        DSU(int n = 0) : p(n + 1), sz(n + 1, 1) { iota(p.begin(), p.end(), 0); }
        int find(int x) { return p[x] == x ? x : p[x] = find(p[x]); }
        void unite(int a, int b) {
            a = find(a);
            b = find(b);
            if (a == b)
                return;
            if (sz[a] < sz[b])
                swap(a, b);
            p[b] = a;
            sz[a] += sz[b];
        }
    };

    bool fun(int n, int m, vector<vector<int>>& edges, int k) {
        DSU dsu(n);
        for (auto x : edges) {
            int u = x[0];
            int v = x[1];
            int t = x[2];
            if (t > m) {
                dsu.unite(v, u);
            }
        }
        int cnt = 0;
        for (int i = 0; i < n; i++)
            if (dsu.find(i) == i)
                cnt++;

        return cnt >= k;
    }

    int minTime(int n, vector<vector<int>>& edges, int k) {
        if (edges.size() == 0)
            return 0;

        long int l = 0, r = -1;
        for (auto x : edges) {
            long int t = x[2];
            r = max(r, t);
        }

        int ans = -1;
        while (l <= r) {
            int m = (l + r) / 2;
            if (fun(n, m, edges, k)) {
                ans = m;
                r = m - 1;
            } else
                l = m + 1;
        }
        return ans;
    }
};Â©leetcode
